{"./":{"url":"./","title":"前言","keywords":"","body":"从零开始学算法 本电子书适用于目标在于掌握基础算法的工程师 简介 作为算法初学者的我从19年8月份开始在力扣学习算法，到现在AC了大约一半的题目。 随着打卡题目数量的增多，我发现力扣常见考察的知识点大概有十几种，包括：二分，滑动窗口，双指针，单调栈（单调队列），链表，二叉树，字符串处理，dfs + 回溯，并查集，动态规划，贪心，位运算，数论（质数、约数、欧拉函数、欧几里得算法、中国剩余定理、简单博弈论等），图论（dfs、bfs、flood fill、拓扑排序、二分染色、最短路、最小生成树）等 系统性地学习算法会有事半功倍的效果，于是我归纳了一些基础算法的知识点，并对力扣上的相关题目进行了整理 这本电子书的目的，是希望帮助大家了解一些基础算法，并掌握其代码模板，快速解决掉一些基本的算法问题。 读者可以根据自己的需要阅读，希望能够对您有所帮助，有何不足之处请多指正！ 本书中所有力扣题目题解收录在力扣题解 ♨️ 目录 力扣题解 二分 排序算法及应用 冒泡排序 快速排序 归并排序 桶排序 字符串处理 DFS和回溯 BFS和记忆化搜索 单调栈 双指针 滑动窗口 前缀和 差分数组 链表 二叉树 二叉树的遍历 深度优先--前序遍历 深度优先--中序遍历 深度优先--后序遍历 广度优先遍历 二叉搜索树 二叉树相关题目 字典树 贪心 区间问题 子集问题 动态规划 线性dp 区间dp 背包dp 树形dp 状态压缩dp 数位dp 计数型dp 递推型dp 概率型dp 博弈型dp 记忆化搜索 并查集 位运算 图论 树与图的遍历 拓扑排序 最短路 朴素的Dijkstra算法 堆优化版的Dijkstra算法 Bellman-Ford算法 spfa算法 Floyd算法 二分图 最小生成树 Prim算法 Kruskal算法 数学 初等数论 容斥原理 抽屉原理 约瑟夫环 卡特兰数 概率论--三门问题 计算几何 进阶 离散化 树状数组 线段树 ST表 推荐学习 OI Wiki Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:33:35 "},"chapter/二分.html":{"url":"chapter/二分.html","title":"二分","keywords":"","body":"二分 应用场景 70%的二分都是跟单调性有关，有单调性的题目一般都可以二分。 95%的题目存在两段性的性质。一部分满足，一部分不满足。 算法思想 将区间分为左右两边（分治），判断中点，确定答案在哪一边，每次缩小一半，直到得到最终答案。 需要注意边界问题 模板 二分模板一共有两个，分别适用于不同情况。 算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 版本1 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1; 计算mid时不需要加1。 C++ 代码模板： int bsearch_1(int l, int r) { while (l > 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本2 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid; 此时为了防止死循环，计算mid时需要加1。 C++ 代码模板： int bsearch_2(int l, int r) { while (l > 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 练习题 概念题 LeetCode 704. Binary Search (easy) LeetCode 69. Sqrt(x) (easy) 二分应用 寻找两个有序数组中第K大的数 LeetCode 33. Search in Rotated Sorted Array (medium) LeetCode 34. Find First and Last Position of Element in Sorted Array (medium) LeetCode 35. Search Insert Position (easy) LeetCode 74. Search a 2D Matrix (medium) LeetCode 153. Find Minimum in Rotated Sorted Array (medium) LeetCode 154. Find Minimum in Rotated Sorted Array II (hard) LeetCode 162. Find Peak Element (medium) LeetCode 275. H-Index II (medium) LeetCode 287. Find the Duplicate Number (medium) LeetCode 300. Longest Increasing Subsequence (medium) LeetCode 315. Count of Smaller Numbers After Self (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/sort/排序.html":{"url":"chapter/sort/排序.html","title":"排序算法及应用","keywords":"","body":"排序算法 我们常说八大排序算法，实际上排序有非常多的算法 这里我们列举常用排序算法极其应用进行说明： 冒泡排序 快速排序 归并 桶排序 板子题 LeetCode 912. Sort an Array (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/sort/冒泡.html":{"url":"chapter/sort/冒泡.html","title":"冒泡排序","keywords":"","body":"冒泡排序 算法思路 进行len-1次冒泡 第k次冒泡将倒数第k个元素排好序 代码实现 function bubbleSort(nums) { for (let i = 0; i nums[j + 1]) { let tmp = nums[j] nums[j] = nums[j+1] nums[j+1] = tmp } } } return nums } Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/sort/快排.html":{"url":"chapter/sort/快排.html","title":"快速排序","keywords":"","body":"快排 快排的思想：递归+分治 不稳定排序，中间交换过程会打乱顺序 时间复杂度：最差O(N^2)，平均O(N^logN) 算法1 取中点为轴（也可以选择其他点） 找到左边第一个大于等于轴的元素A，找到右边第一个大于等于轴的元素B 当A的下标小于B的下标时，交换 递归上述过程 void quick_sort(int q[], int l, int r) { if (l >= r) return; int i = l - 1, j = r + 1, x = q[l + r >> 1]; // 定义左右游标+轴 while (i x); // 找到右边第一个大于等于轴的位置 if (i 算法2 此算法更为直观 选择一个轴（pivot），下标i, j,通过不断移动下标、比较、交换，使得轴左边所有数据小于轴，右边所有数据大于轴； 递归进行上述过程，直到所有数列长度为0或1，排序结束； 由于每次迭代过程，至少有一个值（轴）排好序，所以最终算法会终止； class Solution { public: vector sortArray(vector& nums) { int l =0, r= nums.size()-1; recursive(nums, l, r); return nums; } void recursive(vector& nums, int l, int r){ if (l >= r) return; int pivot = partition(nums, l, r); recursive(nums, l, pivot-1); recursive(nums, pivot+1, r); } int partition(vector& nums, int l, int r){ int pivot = nums[l]; while (l = pivot && l 题目 Top-K问题 LeetCode 215. Kth Largest Element in an Array (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/sort/归并.html":{"url":"chapter/sort/归并.html","title":"归并排序","keywords":"","body":"归并 稳定排序 时间复杂度：O(N^logN) 算法1 int t[100001]; void mergesort(int a[], int l, int r){ if (l >= r) return; int mid = l+r>> 1; mergesort(a, l, mid), mergesort(a, mid+1, r); int i = l, j = mid+1, k= 0; while (i 算法2 function mergeSort(nums) { function recursive(nums, low, high) { if (low >= high) return let mid = (low + high) >> 1 recursive(nums, low, mid) recursive(nums, mid + 1, high) merge(nums, low, mid, high) return nums } function merge(nums, low, mid, high) { let temp = [] // 存储归并结果 let i = 0; // 归并结果游标 let l = low, r = mid + 1 // 左右两边起始下标 while (l 练习题目 剑指offer51. 数组中的逆序对 LeetCode 493. Reverse Pairs (hard) LeetCode 315. Count of Smaller Numbers After Self (hard) LeetCode 327. Count of Range Sum (hard) LeetCode 148. Sort List (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/sort/桶排序.html":{"url":"chapter/sort/桶排序.html","title":"桶排序","keywords":"","body":"桶排序 桶排序 的两个步骤： 分桶 合并 基数排序 先按个位进行桶排序 然后按十位进行桶排序 然后按百位进行桶排序 ... 直到所有位完成桶排序，最后的序列就是排好序的 比如：452，897，472，385，752 按个位：452，472，752，385，897 按十位：452，752，472，385，897 按百位：385，452，472，752，897 已经排好序 计数排序 统计每一个数字出现的次数，输出次数次即可 题目 LeetCode 164. Maximum Gap (hard) LeetCode 220. Contains Duplicate III (medium) LeetCode 451. Sort Characters By Frequency (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/字符串处理.html":{"url":"chapter/字符串处理.html","title":"字符串处理","keywords":"","body":"字符串处理 字符串处理题目特点 题目难度一般不会很高，主要考察细节 注意是否越界 常用代码模板 查找下一个不相等的字符 找到第一个s[j] != s[i] 或者j==n 双指针的思想 while (j KMP算法 输入样例： 3 aba 5 ababa 输出样例： 0 2 代码实现 const int N = 10010, M = 100010; int n, m; int ne[N]; char s[M], p[N]; // s: 模式串；t: 模板串 int main() { cin >> n >> p + 1 >> m >> s + 1; for (int i = 2, j = 0; i 题目 LeetCode 38. Count and Say (easy) LeetCode 49. Group Anagrams (medium) LeetCode 151. Reverse Words in a String (medium) LeetCode 165. Compare Version Numbers (medium) LeetCode 929. Unique Email Addresses (easy) LeetCode 5. Longest Palindromic Substring (medium) LeetCode 6. ZigZag Conversion (medium) LeetCode 208. Implement Trie (Prefix Tree) (medium) LeetCode 273. Integer to English Words (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/DFS和回溯.html":{"url":"chapter/DFS和回溯.html","title":"DFS和回溯","keywords":"","body":"DFS & 递归 & 回溯 & 剪枝 这四种算法结合使用，可以解决几类问题 排列组合问题 棋盘搜索的问题，往往是在一个棋盘上查找最短路径、路径方案数 递归代码模板 递归即为闭包 func dfs(){ doSomeThing() dfs() doAnotherThing() } 回溯即附加条件后，递归下一状态之前，要回退上一步附加操作 func dfs(){ change() dfs() unchange() } dfs & 递归 & 回溯 & 剪枝 结合使用，代码模板 for all router { // 遍历所有路径 doCounter() // 统计结果 doCut() // 剪枝 func dfs(){ // 深搜 doSomeThing() // 搜索处理，保存当前状态等 change() // 当前棋盘变化 dfs() // 递归 unchange() // 回溯棋盘变化（恢复现场） doAnotherThing() } } 适用于解决的问题特征 深度优先搜索经常用来处理数据量非常庞大的问题 比如数独问题，用宽搜搜不完的 常用于解决树形问题 宽度优先搜索经常用来处理最短路径，或最短距离 深度搜索不一定等于递归，也可以用循环来实现 所谓回溯就是恢复初始状态（恢复现场） 如果我们的状态是整个棋盘，就需要恢复现场，如果是某一个格子，就不需要恢复现场 经典问题 引入几个简单问题，帮助大家理解概念 递归经典问题：汉诺塔 回溯经典问题：八皇后 递归经典问题：汉诺塔 三座塔A, B, C，求移动的最小次数 分三步： 把上面的n-1，从A->B; 把最下面的盘子，从A->C; 把B上的n-1，从B->A; 递归求解 function Hanoi(n){ if (n == 1) return 1 if (n == 2) return 3 return 2*Hanoi(n-1) + 1 // 可以通过递推公式得到 } 面试题 08.06. 汉诺塔问题 拓展： 四座塔A, B, C, D, 求移动的最小次数。 转自acwing 可以进行动态规划，递推求解 #include using namespace std; int d[21],f[21],i,j; int main() { for (i=1;i 所有递归问题都可以转化为递推求解 比如题目LeetCode 62. Unique Paths (medium)可以使用递归求路径总数，也可以用动态规划，根据状态转换方程，递推求解 我的习惯是如果方便使用递推求解，可以直接递推，如果递归更容易理解，也可以递归 递归的问题是：容易出现爆栈，而且一旦逻辑出错，定位问题的难度也要高于递推 回溯经典问题：八皇后问题 八皇后问题是讲解回溯的经典案例 参考 LeetCode 51. N-Queens (hard) 题目分类 排列、组合、子集问题 组合、排列、子集 问题 属于一类基础问题，有一些问题会抽象成求解组合、排列、子集 这类问题数据量不会太大 往往可以用DFS进行暴搜求解 排列问题 题目特征: 请枚举所有排列 LeetCode 46. Permutations (medium) LeetCode 47. Permutations II (medium) 拓展 LeetCode 996. Number of Squareful Arrays (hard) 组合问题 求所有组合方案; 如果存在重复，则需要排序，过滤重复位置 题目 题目特征: 请枚举所有组合 LeetCode 39. Combination Sum (medium) LeetCode 40. Combination Sum II (medium) LeetCode 216. Combination Sum III (medium) 拓展 LeetCode 93. Restore IP Addresses (medium) LeetCode 131. Palindrome Partitioning (medium) 子集问题 题目特征: 请枚举所有子集 LeetCode 78. Subsets (medium) LeetCode 90. Subsets II (medium) 棋盘搜索 棋盘搜索一般配合 DFS + memorization LeetCode 351. Android Unlock Patterns (medium) LeetCode 329. Longest Increasing Path in a Matrix (hard) LeetCode 52. N-Queens II (hard) LeetCode 37. Sudoku Solver (hard) LeetCode 473. Matchsticks to Square (medium) 其他问题 LeetCode 22. Generate Parentheses (medium) LeetCode 131. Palindrome Partitioning (medium) LeetCode 306. Additive Number (medium) LeetCode 17. Letter Combinations of a Phone Number (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/单调栈.html":{"url":"chapter/单调栈.html","title":"单调栈","keywords":"","body":"单调栈（单调队列） 单调栈是一种维护栈内元素递增(或递减)的栈。 单调栈分为单调递增栈和单调递减栈，单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈。 单调栈里可以保存元素的值或下标 某些场景下，我们需要维护栈底，这时候栈的数据结构是不满足要求的，可能需要借助队列或双端队列实现（比如求滑动窗口最大值），即单调队列 应用场景 可以在O(N)的时间复杂度，找出每个数左右两边第一个大于或小于它的解 单调递增栈用于查找两边第一个小于当前元素的值，单调递减栈用于查找两边第一个大于当前元素的值 一般数组中的单调性问题，题目中隐含第一个或离此元素最近的大于或小于元素的值，这类问题都可以考虑下，用单调栈是否可以求解 动画演示 数列7 4 9 5 3 2构建单调递减栈 代码模板 stack stk; for (int i = 0; i = A[stk.top()] stk.pop(); } stk.push(i); } 板子题 给定一个长度为N的正整数数组，输出每个数左右两边第一个比它小的数，如果不存在则输出-1。 输入: [3, 4, 2, 7, 5] 输出： 左边：[-1, 3, -1, 2, 2] 右边：[2, 2, -1, 5, -1] 解题思路 查找左右两边第一个更小的元素，使用单调递增栈 入栈时，当前元素左边的第一个更小的元素是当前栈顶元素 出栈时，栈顶右边第一个更小的元素是即将入栈的当前元素 代码实现 void sumSubarrayMins(vector &A) { int n = A.size(); vector lmin(n, -1); vector rmin(n, -1); stack stk; // 单调递增栈 for (int i = 0; i 时间复杂度O(N)，空间复杂度O(N) 题目 LeetCode 239. Sliding Window Maximum (hard) LeetCode 42. Trapping Rain Water (hard) LeetCode 84. Largest Rectangle in Histogram (hard) LeetCode 85. Maximal Rectangle (hard) LeetCode 402. Remove K Digits (medium) LeetCode 503. Next Greater Element II (medium) LeetCode 768. Max Chunks To Make Sorted II (hard) LeetCode 739. Daily Temperatures (medium) LeetCode 901. Online Stock Span (medium) LeetCode 1019. Next Greater Node In Linked List (medium) LeetCode 907. Sum of Subarray Minimums (medium) 全局单调栈 上面我们遇到的单调栈问题，都是维护的连续性的局部子序列的单调性，还有一类问题，需要求解全局性的单调性序列， LeetCode 962. Maximum Width Ramp (medium) LeetCode 1124. Longest Well-Performing Interval (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/双指针.html":{"url":"chapter/双指针.html","title":"双指针","keywords":"","body":"双指针问题 双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的 应用场景 双指针是很多算法的基础，如归并排序、滑动窗口、字符匹配（左右括号匹配）等 在很多情况下，双指针能帮助我们找到空间或是时间复杂度更低的解。比单个指针来回移动的效率从提高到 模板 for (int i = 0, j = 0; i 常见问题分类 对于一个序列，用两个指针维护一段区间 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 题目 LeetCode 32. Longest Valid Parentheses (hard) LeetCode 76. Minimum Window Substring (hard) LeetCode 799. Champagne Tower (medium) LeetCode 962. Maximum Width Ramp (medium) LeetCode 1124. Longest Well-Performing Interval (medium) AcWing800.数组元素的目标和 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/滑动窗口.html":{"url":"chapter/滑动窗口.html","title":"滑动窗口","keywords":"","body":"滑动窗口 算法思路 使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 先不断地增加 right 指针扩大窗口 [left, right]，直到窗口符合要求 停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达尽头。 第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。 左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。 注意: 滑动窗口适用的题目一般具有单调性 滑动窗口、双指针、单调队列和单调栈经常配合使用 代码模板 int left = 0, right = 0; // 左右指针 while (right 练习题目 LeetCode 239. Sliding Window Maximum (hard) LeetCode 480. Sliding Window Median (hard) LeetCode 3. Longest Substring Without Repeating Characters (medium) LeetCode 76. Minimum Window Substring (hard) LeetCode 395. Longest Substring with At Least K Repeating Characters (medium) LeetCode 567. Permutation in String (medium) LeetCode 438. Find All Anagrams in a String (medium) LeetCode 209. Minimum Size Subarray Sum (medium) LeetCode 424. Longest Repeating Character Replacement (medium) LeetCode 1208. Get Equal Substrings Within Budget (medium) LeetCode 904. Fruit Into Baskets (medium) LeetCode 978. Longest Turbulent Subarray (medium) TODO LeetCode 992. Subarrays with K Different Integers (hard) LeetCode 995. Minimum Number of K Consecutive Bit Flips (hard) LeetCode 1040. Moving Stones Until Consecutive II (medium) LeetCode 1052. Grumpy Bookstore Owner (medium) LeetCode 1074. Number of Submatrices That Sum to Target (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/前缀和.html":{"url":"chapter/前缀和.html","title":"前缀和","keywords":"","body":"前缀和 一维前缀和 S[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] AcWing 795. 前缀和 二维前缀和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] AcWing 796. 子矩阵的和 LeetCode 1074. Number of Submatrices That Sum to Target (hard) 题目 LeetCode 134. Gas Station (medium) LeetCode 303. Range Sum Query - Immutable (easy) LeetCode 304. Range Sum Query 2D - Immutable (medium) LeetCode 307. Range Sum Query - Mutable (medium) LeetCode 325. Maximum Size Subarray Sum Equals k (medium) LeetCode 410. Split Array Largest Sum (hard) LeetCode 554. Brick Wall (medium) LeetCode 560. Subarray Sum Equals K (medium) LeetCode 1094. Car Pooling (medium) LeetCode 1109. Corporate Flight Bookings (medium) LeetCode 1124. Longest Well-Performing Interval (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/差分数组.html":{"url":"chapter/差分数组.html","title":"差分数组","keywords":"","body":"差分数组 差分数组记录节点位置的修改值； 一维差分 给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c 二维差分 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 题目 AcWing 797. 差分 AcWing 798. 差分矩阵 领扣391. 数飞机 LeetCode 1094. Car Pooling (medium) LeetCode 1109. Corporate Flight Bookings (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/链表.html":{"url":"chapter/链表.html","title":"链表","keywords":"","body":"链表 力扣上链表相关题目总结 解题技巧 快慢指针，用于定位节点 巧用dummpy，在头结点发生改变时，不需要考虑头结点的特殊处理，只要返回dummpy->next作为头结点即可 查找 查找链表中的指定位置，一般会用到快慢指针的配合 比如：找环，找倒数第K个节点，找中间节点等等 LeetCode 142. Linked List Cycle II (medium) LeetCode 160. Intersection of Two Linked Lists (easy) 删除 一般涉及到删除操作，会考虑在开头增加辅助节点dummpy 这样就不需要考虑删除链表头的特殊情况的处理 LeetCode 19. Remove Nth Node From End of List (medium) LeetCode 237. Delete Node in a Linked List (easy) LeetCode 83. Remove Duplicates from Sorted List (easy) 旋转链表 LeetCode 61. Rotate List (medium) LeetCode 206. Reverse Linked List (easy) LeetCode 92. Reverse Linked List II (medium) 重排链表 重排链表，有时会用到分治和递归的思路 LeetCode 24. Swap Nodes in Pairs (medium) LeetCode 86. Partition List (medium) LeetCode 143. Reorder List (medium) LeetCode 148. Sort List (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/二叉树.html":{"url":"chapter/binary-tree/二叉树.html","title":"二叉树","keywords":"","body":"二叉树 二叉树是一种常见的基础数据结构，以二分叉的特点得名 二叉树节点一般包含值、左节点、右节点三个属性 学习大纲 二叉树涉及到的知识点 一般 包括： 二叉树的遍历 二叉搜索树（一种特殊的二叉树） Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/二叉树的遍历.html":{"url":"chapter/binary-tree/二叉树的遍历.html","title":"二叉树的遍历","keywords":"","body":"二叉树的遍历 二叉树有深度优先和广度优先两种遍历方式 其中深度优先遍历（dfs）又分为前序、中序、后序三种遍历方式 可以用递归和非递归方式实现 深度优先搜索 前序遍历 中序遍历 后序遍历 宽度优先搜索 深度优先搜索模板 搜索模板 public class Solution { public void traverse(TreeNode root) { if (root == null) { return; } // do something with root traverse(root.left); // do something with root traverse(root.right); // do something with root } } 分治模板 public class Solution { public ResultType traversal(TreeNode root) { // null or leaf if (root == null) { // do something and return; } // Divide ResultType left = traversal(root.left); ResultType right = traversal(root.right); // Conquer ResultType result = Merge from left and right. return result; } } Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/深度优先--前序遍历.html":{"url":"chapter/binary-tree/深度优先--前序遍历.html","title":"深度优先--前序遍历","keywords":"","body":"前序遍历 遍历顺序：根左右 递归 func dfs(root){ visit(root) dfs(root.left) dfs(root.right) } 代码实现 class Solution { private: vector ans; public: vector preorderTraversal(TreeNode* root) { dfs(root); return ans; } void dfs(TreeNode* root){ if (!root) return ; ans.push_back(root->val); dfs(root->left); dfs(root->right); } }; 非递归方式 用指针p表示当前位置，用一个来栈记录访问顺序 对于每一个当前节点p，先访问p, 然后右子树入栈，然后访问左子树 栈S; p= root; while(p || S不空){ while(p){ 访问p节点； p的右子树入S; p = p的左子树; } p = S栈顶弹出; } 代码实现 class Solution { public: vector preorderTraversal(TreeNode* root) { vector ans; TreeNode* p = root; vector stk; while (p || !stk.empty()){ while (p){ ans.push_back(p->val); stk.push_back(p->right); p = p->left; } p = stk.back(); stk.pop_back(); } return ans; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/深度优先--中序遍历.html":{"url":"chapter/binary-tree/深度优先--中序遍历.html","title":"深度优先--中序遍历","keywords":"","body":"中序遍历 中序遍历：左根右 递归方式 func dfs(root){ dfs(root.left) visit(root) dfs(root.right) } 非递归方式 思路： 先把左子树都进栈，依次出栈，访问左子树，出栈过程把右子树都入栈， 这样访问的顺序就是 左 根 右； 用一个指针p标记当前游标，一个栈保存访问顺序 对于每一个当前节点p，先把左节点全部入栈，在出栈的过程中，依次访问根节点，右子树 栈S; p = root; while(p || S不空){ while(p){ p入S; p = p的左子树; } p = S.top 出栈; 访问p; p = p的右子树; } cpp代码实现 class Solution { public: vector inorderTraversal(TreeNode* root) { if (!root) return {}; vector stk = {}; vector ans; TreeNode* p = root; while (p || !stk.empty()){ while(p){ stk.push_back(p); p = p->left; } p = stk.back(); ans.push_back(p->val); stk.pop_back(); p = p->right; } return ans; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/深度优先--后序遍历.html":{"url":"chapter/binary-tree/深度优先--后序遍历.html","title":"深度优先--后序遍历","keywords":"","body":"后序遍历 递归思路 var postorderTraversal = function(root) { let ans = [] function dfs(root){ if (!root) return dfs(root.left) dfs(root.right) ans.push(root.val) } dfs(root) return ans }; 非递归思路 先得到根右左，然后逆序得到左右根 得到根右左的过程类似先序得到根左右，先把右子树访问完，把左子树压栈 栈S; p= root; while(p || S不空){ while(p){ 访问p节点； p的左子树入S; p = p的右子树; } p = S栈顶弹出; } 结果序列逆序; 代码实现： class Solution { public: vector postorderTraversal(TreeNode* root) { vector ans; vector stk; TreeNode* p = root; while (p || !stk.empty()){ while(p){ ans.push_back(p->val); stk.push_back(p->left); p = p->right; } p = stk.back(); stk.pop_back(); } reverse(ans.begin(), ans.end()); return ans; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/广度优先遍历.html":{"url":"chapter/binary-tree/广度优先遍历.html","title":"广度优先遍历","keywords":"","body":"广度优先遍历 也叫 层遍历，BFS 遍历过程是从上到下，一层一层的，更接近人的思维 实现方式 BFS 需要 借助 队列 来实现 应用场景 求解最短、最小路径问题 图的拓扑排序 最短路问题求解（dijkstra算法等） 优点和缺点 优点： 接近人的思维，易于理解 不会爆栈 求最短路 缺点： 代码实现较长 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/二叉搜索树.html":{"url":"chapter/binary-tree/二叉搜索树.html","title":"二叉搜索树","keywords":"","body":"二叉搜索树 二叉搜索树的性质 结点左子树中所含结点的值小于等于当前结点的值 结点右子树中所含结点的值大于等于当前结点的值 左子树和右子树都是二叉搜索树 判断条件 中序遍历是递增序列的二叉树一定是二叉搜索树，可以利用中序遍历是否有序判断是否二叉搜索树 根节点大于所有左子树节点，如果根节点大于左子树的最大值节点即可，因为左子树的最大值位于左子树最右边的节点，所以只要根节点 > 左子树的最右节点即可；同理，根节点 寻找左子树的最右节点（寻找右子树的最左节点） 题目 LeetCode 426. Convert Binary Search Tree to Sorted Doubly Linked List (medium) LeetCode 530. Minimum Absolute Difference in BST (easy) LeetCode 230. Kth Smallest Element in a BST (medium) LeetCode 501. Find Mode in Binary Search Tree (easy) LeetCode 938. Range Sum of BST (easy) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/binary-tree/练习题目.html":{"url":"chapter/binary-tree/练习题目.html","title":"二叉树相关题目","keywords":"","body":"题目 LeetCode 94. Binary Tree Inorder Traversal (medium) LeetCode 98. Validate Binary Search Tree (medium) LeetCode 101. Symmetric Tree (easy) LeetCode 104. Maximum Depth of Binary Tree (easy) LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal (medium) LeetCode 108. Convert Sorted Array to Binary Search Tree (easy) LeetCode 109. Convert Sorted List to Binary Search Tree (medium) LeetCode 110. Balanced Binary Tree (easy) LeetCode 124. Binary Tree Maximum Path Sum (hard) LeetCode 129. Sum Root to Leaf Numbers (medium) LeetCode 173. Binary Search Tree Iterator (medium) LeetCode 235. Lowest Common Ancestor of a Binary Search Tree (easy) LeetCode 236. Lowest Common Ancestor of a Binary Tree (medium) LeetCode 437. Path Sum III (easy) LeetCode 513. Find Bottom Left Tree Value (medium) LeetCode 538. Convert BST to Greater Tree (easy) LeetCode 543. Diameter of Binary Tree (easy) LeetCode 863. All Nodes Distance K in Binary Tree (medium) LeetCode 889. Construct Binary Tree from Preorder and Postorder Traversal (medium) LeetCode 951. Flip Equivalent Binary Trees (medium) LeetCode 958. Check Completeness of a Binary Tree (medium) LeetCode 979. Distribute Coins in Binary Tree (medium) LeetCode 1008. Construct Binary Search Tree from Preorder Traversal (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/字典树.html":{"url":"chapter/字典树.html","title":"字典树","keywords":"","body":"Trie树 Trie树，又称前缀树或字典树 基本性质 根节点不包含字符，除根节点以外每个节点只包含一个字符 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串 每个节点的所有子节点包含的字符串不相同 字典树模板 单词构成全部是小写字母a-z的情况 cpp模板 struct treeNode { bool isEnd; // 是否存在已当前位置结尾的单词 treeNode *next[26]; // 仅适用于全部是小写字母a-z的情况；更为鲁棒的情况`map next;` treeNode() { isEnd = false; memset(next, 0, sizeof(next)); } }; class Trie { public: treeNode *root; // 共有变量，供外部程序访问字典树 Trie() { root = new treeNode(); } void insert(const string &word) { treeNode *node = root; for (char c : word) { if (node->next[c - 'a'] == NULL) { node->next[c - 'a'] = new treeNode(); // 存在分支 } node = node->next[c - 'a']; // 向后插入字符 } node->isEnd = true; // 到达单词某位 } bool search(const string &word) { treeNode *node = root; for (char c : word) { node = node->next[c - 'a']; // 向后迭代 if (node == NULL) { return false; // 当前位置字符不存在 } } return node->isEnd; // 搜索存在单词 } bool startsWith(const string &prefix) { treeNode *node = root; for (char c : prefix) { node = node->next[c - 'a']; // 向后迭代 if (node == NULL) { return false; // 当前位置字符不存在 } } return node != NULL; // 最后一个字符存在 } }; 应用场景 字符串检索 事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。 举例： 给出N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。 给出一个词典，其中的单词为不良单词。单词均为小写字母。再给出一段文本，文本的每一行也由小写字母构成。判断文本中是否含有任何不良单词。例如，若rob是不良单词，那么文本problem含有不良单词。 1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串。 文本预测、自动完成，see also，拼写检查 词频统计 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。 一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。 寻找热门查询：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，这些查询串的重复度比较高，虽然总数是1千万，但是如果去除重复，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就越热门。请你统计最热门的10个查询串，要求使用的内存不能超过1G。 排序 Trie树是一棵多叉树，只要先序遍历整棵树，输出相应的字符串便是按字典序排序的结果。 比如给你N 个互不相同的仅由一个单词构成的英文名，让你将它们按字典序从小到大排序输出。 字符串最长公共前缀 Trie树利用多个字符串的公共前缀来节省存储空间，当我们把大量字符串存储到一棵trie树上时，我们可以快速得到某些字符串的公共前缀。 举例： 给出N 个小写英文字母串，以及Q 个询问，即询问某两个串的最长公共前缀的长度是多少？ 解决方案：首先对所有的串建立其对应的字母树。此时发现，对于两个串的最长公共前缀的长度即它们所在结点的公共祖先个数，于是，问题就转化为了离线（Offline）的最近公共祖先（Least Common Ancestor，简称LCA）问题。 而最近公共祖先问题同样是一个经典问题，可以用下面几种方法： 利用并查集（Disjoint Set），可以采用采用经典的Tarjan 算法； 求出字母树的欧拉序列（Euler Sequence）后，就可以转为经典的最小值查询（Range Minimum Query，简称RMQ）问题了； 字符串搜索的前缀匹配 trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。 Trie树检索的时间复杂度可以做到n，n是要检索单词的长度，如果使用暴力检索，需要指数级O(n2)的时间复杂度。 作为其他数据结构和算法的辅助结构 如后缀树，AC自动机等 后缀树可以用于全文搜索 题目 LeetCode 208. Implement Trie (Prefix Tree) (medium) LeetCode 211. Add and Search Word - Data structure design (medium) LeetCode 140. Word Break II (hard) LeetCode 212. Word Search II (hard) LeetCode 820. Short Encoding of Words (medium) LeetCode 1268. Search Suggestions System (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/greedy/贪心.html":{"url":"chapter/greedy/贪心.html","title":"贪心","keywords":"","body":"贪心 每次都求最优解，以局部最优得到全局最优 贪心是动态规划的一种特殊类型的题目 概念题 找零钱：有1，2，5三种面值的钞票，每件商品售价3元，输入顾客付款的钞票面额顺序，问能否找零？ 算法思路：优先找较大面值的钱 题目来源：LeetCode 860. Lemonade Change (easy) 常见问题 区间问题 区间问题 跳跃游戏 LeetCode 55. Jump Game (medium) LeetCode 45. Jump Game II (hard) LeetCode 1306. Jump Game III (medium) LeetCode 1345. Jump Game IV (hard) LeetCode 1340. Jump Game V (hard) 其他问题 LeetCode 455. Assign Cookies (easy) LeetCode 392. Is Subsequence (easy) LeetCode 376. Wiggle Subsequence (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/greedy/区间问题.html":{"url":"chapter/greedy/区间问题.html","title":"区间问题","keywords":"","body":"区间问题 区间问题是贪心中常见的一类问题 常用扫描线算法（sweep-line）去解决 一般需要先对其起始位置信息进行排序，然后考虑区间的起始位置如何处理，得到最优解 解决区间问题的通用思路 将每个区间按左端点（或者右端点）进行排序 从前往后依次枚举每个区间，贪心策略计算结果 四类区间问题 题目来源 AcWing 905. 区间选点 AcWing 908. 最大不相交区间数量 AcWing 906. 区间分组 AcWing 907. 区间覆盖 区间选点 给定N个闭区间[ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。 输出选择的点的最小数量。 位于区间端点上的点也算作区间内。 实际问题：用最少的箭射爆所有气球 算法思路： 将所有区间按照右端点从小到大排序 从前往后枚举每个区间 如果当前区间已经包含点，直接pass 否则结果加一，选择当前区间的右端点，继续枚举后面的区间 最多不想交区间 给定N个闭区间，选择若干区间，使得选中的区间之间互不相交（包括端点）。 输出可选取区间的最大数量。 实际问题：很多课程，或者活动，我们从中选择最多数量的课程或活动参加 算法思路：跟区间选点一致 区间分组 给定N个闭区间，将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。 输出最小组数。 实际问题：公司今天有20场会议，问最少用几个会议室可以安排下 算法思路： 将所有区间按照左端点从小到大排序 从前往后处理每个区间 判断能否将其放到某个现有的组中（小顶堆维护右端点（最早结束的区间）） 区间覆盖 给定N个闭区间[ai,bi]以及一个线段区间[s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。 输出最少区间数，如果无法完全覆盖则输出-1。 算法思路： 将所有区间按左端点从小到大排序 从前往后依次枚举每个区间，在所有能覆盖start的区间中选择右端点最大的，然后将start更新成右端点的最大值 题目 LeetCode 452. Minimum Number of Arrows to Burst Balloons (medium) LeetCode 253. Meeting Rooms II (medium) LeetCode 218. The Skyline Problem (hard) LeetCode 1235. Maximum Profit in Job Scheduling (hard) 领扣 391. 数飞机 给出飞机起飞，降落时间，求天上最多有多少架飞机 扫描线算法：记录 扫描线坐标（起飞降落时间点），记录起飞降落动作，用差分数组的思想，起飞 +1，降落 -1，求最大值 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/greedy/子集问题.html":{"url":"chapter/greedy/子集问题.html","title":"子集问题","keywords":"","body":"子集问题 求满足某一性质的最优子集，如最长序列等 应用场景 在一个集合中选出子集 集合在某一方面的性质存在单调性 一般会隐含最优、最大等条件 经典题目：俄罗斯套娃 LeetCode 354. Russian Doll Envelopes (hard) 题目 LeetCode 135. Candy (hard) LeetCode 857. Minimum Cost to Hire K Workers (hard) LeetCode 1283. Find the Smallest Divisor Given a Threshold (medium) 面试题 17.08. 马戏团人塔 面试题 08.13. 堆箱子 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/动态规划.html":{"url":"chapter/dp/动态规划.html","title":"动态规划","keywords":"","body":"动态规划 动态规划（Dynamic Programming）是一种分阶段求解策略问题的数学思想。 动态规划中包含三个重要概念：最优子结构、边界、状态转移公式。 最优子结构，求解一个问题时，首先要找出问题的最优子结构； 边界，边界是最简的最优子结构，无需再简化便可得到结果；如果一个问题没有边界，将无法得到有限的结果； 状态转换方程，是阶段与阶段直接的转换关系 动态规划类似于高中数学的数学归纳法 求解过程 确定状态 研究最优策略的最后一步，转化为子问题，定义最优子结构 转换方式 根据子问题定义和最后一步求解过程，抽象出状态转换方程 初始条件和边界情况 细心，考虑周全 计算顺序 利用之前的计算结果 动态规划题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和为sum 求最值 从左上角走到右下角路径的最大数字和 求最长上升子序列的长度 求存在性 青蛙过河，能否跳到最后一个位置 取石子游戏，先手是否必胜 能不能选出k个数使得和是sum 常见动态规划题型 线性dp 区间dp 背包dp 树形dp 状态压缩dp 数位dp 计数型dp 递推型dp 概率型dp 博弈型dp 记忆化搜索 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/线性dp.html":{"url":"chapter/dp/线性dp.html","title":"线性dp","keywords":"","body":"线性dp 线性dp的模型是线性的 问题分类 线性dp可以按分析方式分为几类： 坐标型（一维坐标，二维坐标） 划分型（将序列分成若干段，每一段具有最大/最小的性质） 坐标型 坐标记录状态 可以用滚动数组进行空间优化 一维坐标 硬币组合: 足够的2，5，7面值的硬币，问最少用多少个硬币能组合出面值27（有多少种方式凑出面值27） f(i) 表示凑出i元所有的最少硬币数（凑出i元的方案数） LeetCode 518. Coin Change 2 (medium) 面试题46. 把数字翻译成字符串 二维坐标 不同路径：在一个二维棋盘中，机器人从左上角走到右下角，有多少种走法 LeetCode 64. Minimum Path Sum (medium) 炸弹袭击 二维矩阵中的格子为空，敌人，墙，炸弹可以放在任意空地上，炸弹会杀死同一行和同一列没有墙阻隔的敌人；问一个炸弹杀死的最大敌人数 领扣553. 炸弹袭击 算法思路： 记录dp[i][j][0,1,2,3]分别为向四个方向能炸死的敌人数目 从四个方向，做差分，记录每个位置在此方向上能够炸死的敌人数目 四个方向求和，迭代得最大值 最长序列 LeetCode 300. Longest Increasing Subsequence (medium) LeetCode 1143. Longest Common Subsequence (medium) 图形问题 根据棋盘中图形的性质，通过相邻坐标的状态，进行推导 矩形统计 LeetCode 221. Maximal Square (medium) LeetCode 1277. Count Square Submatrices with All Ones (medium) 序列型 序列型一般分为单序列、双序列 一般需要自定义空序列表示f[0] 有时候会有K维序列，表示K种状态 房子涂色 LeetCode 256. Paint House (easy) LeetCode 265. Paint House II (hard) 打家劫舍系列 LeetCode 198. House Robber (easy) LeetCode 213. House Robber II (medium) 打家劫舍3 是树形DP 股票系列 LeetCode 121. Best Time to Buy and Sell Stock (easy) LeetCode 122. Best Time to Buy and Sell Stock II (easy) LeetCode 123. Best Time to Buy and Sell Stock III (hard) LeetCode 188. Best Time to Buy and Sell Stock IV (hard) LeetCode 309. Best Time to Buy and Sell Stock with Cooldown (medium) LeetCode 714. Best Time to Buy and Sell Stock with Transaction Fee (medium) 字符串匹配系列 LeetCode 10. Regular Expression Matching (hard) LeetCode 44. Wildcard Matching (hard) LeetCode 72. Edit Distance (hard) 划分型 给定长度为N的序列，要求划分为若干段 段数不限，或指定K段 每一段满足一定的性质（最小代价，能不能等） 做法： 类似于序列型动态规划，但是通常要加上段数信息 一般用f[i + 1][k]来记录前i个元素（元素0~i-1,f[0][k]表示空序列）分成k段的性质，如最小代价 关注最后一段，枚举最后一段可能情况 + 前面序列, 求最优策略 注意：划分型动态规划每一段序列一定是连续的 数字规律一类题目（一维坐标） 把一个完整的数字分成几个，满足一定的性质 LeetCode 279. Perfect Squares (medium) LeetCode 343. Integer Break (medium) 此类问题往往也可以用完全背包模型去解决 解码方法 LeetCode 91. Decode Ways (medium) 分割回文串 LeetCode 132. Palindrome Partitioning II (hard) LeetCode 1278. Palindrome Partitioning III (hard) 抄写书籍（领扣437） N本书，每本有A[i]页；K个抄写员，每个抄写员可以抄连续的几本书；抄写员抄写速度一样；问最少需要多长时间抄写完毕。 可以用贪心，动态规划更通用，如果稍微变形，贪心就不可以用了 LeetCode 410. Split Array Largest Sum (hard) 鸡蛋掉落 LeetCode 887. Super Egg Drop (hard) 经典问题 LeetCode 300. Longest Increasing Subsequence (medium) LeetCode 1143. Longest Common Subsequence (medium) LeetCode 120. Triangle (medium) LeetCode 53. Maximum Subarray (easy) LeetCode 152. Maximum Product Subarray (medium) LeetCode 887. Super Egg Drop (hard) LeetCode 354. Russian Doll Envelopes (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/区间dp.html":{"url":"chapter/dp/区间dp.html","title":"区间dp","keywords":"","body":"区间dp 区间dp是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态f(i,j)表示将下标位置 i 到 j 的所有元素合并能获得的价值的最大值，那么 f(i,j) = max{f(i,k) + f(k+1, j) + cost}, cost 为将这两组元素合并起来的代价。 区间 DP 的特点： 合并：即将两个或多个部分进行整合，当然也可以反过来； 特征：能将问题分解为能两两合并的形式； 求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。 一般用二维数组表示区间 区间问题只需要考虑 区间头和区间尾 题目 LeetCode 516. Longest Palindromic Subsequence (medium) LeetCode 877. Stone Game (medium) LeetCode 87. Scramble String (hard) LeetCode 312. Burst Balloons (hard) LeetCode 546. Remove Boxes (hard) Acwing282. 石子合并 LeetCode 1000. Minimum Cost to Merge Stones (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/背包dp.html":{"url":"chapter/dp/背包dp.html","title":"背包dp","keywords":"","body":"背包dp 背包问题是一类动态规划问题 对于背包问题的学习，推荐看下dd大牛的《背包九讲》 背包问题分类 01背包问题 每件物品最多用1次 完全背包问题 每件物品有无限个 多重背包问题 每种物品有Si个 分组背包问题 一组里面只能选一种 混合背包问题 二维费用的背包问题 背包问题求方案数 求背包问题的方案 有依赖的背包问题 我们重点掌握常用的背包四讲，即：01背包、完全背包、多重背包、分组背包 01背包问题 每个物品有一定价值和容量，要么取要么不取，只能取一次 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 输入： N 件物品 V 容量 v[N] 体积 w[N] 价值 算法思路 01背包是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 我们可以选择二维或一维解决01背包 二维解决01背包 dp[i][j] 表示前i种物品，体积为j能放下的最大价值 一维解决01背包 dp[j]表示体积为j能放下的最大价值 代码实现 function maxValue(N, V, v, w) { let dp = new Array(V + 1).fill(0) for (let i = 0; i = v[i]; j--) { // 循环体积；从大到小； dp[j] = Math.max(dp[j], dp[j - v[i]] + w[i]) } } return dp[V] } 只用一维数组解01背包问题是十分必要的。我们最常使用的也是一维的方式。 题目 LeetCode 300. Longest Increasing Subsequence (medium) LeetCode 416. Partition Equal Subset Sum (medium) 总结 01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想， 另外，别的类型的背包问题往往也可以转换成01背包问题求解。 故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。 完全背包问题 在01背包基础上，每个物品可以取无数次 有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。 第 i 种物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。 输出最大价值。 dp[i]表示总体积为i的情况下的最大价值 代码模板 function maxValue(N, V, v, w) { let dp = new Array(V + 1).fill(0) for (let i = 0; i 多重背包问题 每种物品有一个固定取数的上限 有 N 种物品和一个容量是 V 的背包。 第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。 输出最大价值。 输入样例 4 5 1 2 3 2 4 1 3 4 3 4 5 2 输出样例： 10 数据范围 0 f[i] 表示总体积是i的情况下的最大价值； #include using namespace std; const int N = 110; int n, m; int f[N]; int main(){ cin >> n >> m; for (int i = 0; i> v >> w >> s; for (int j = m; j >= 0; j--){ for (int k =1; k 多重背包的二进制优化 数据范围 0 如果上面数据范围仍按照三维循环去求解，时间复杂度将会达到2e9，会TLE 优化方法：通过把物品件数拆为二进制份，转化为01背包问题求解 二进制拆分算法： 比如10个物品，我们可以拆成 1，2，4 和 3（10-1-2-4得到），则1，2，4，3可以组合得到1到10的所有数字， 如何证明? 证明：s分为两部分 1,2,4,8,...,2^k 和 s - 2^k,前半部分，我们可以通过二进制表示证明1到2^k都可取，剩下部分s - 2^k的取值范围在[0,2^k)之间，我们可以想象把后半部分移到前面，前半部分移到后面，可以得到后半部分的任意取值也都可以得到 #include using namespace std; const int N = 2010; int n, m; int f[N] = {0}; struct Good { int v, w; }; int main(){ cin >> n >> m; vector goods; for (int i = 0; i> v >> w >> s; for (int k = 1; k 0) goods.push_back({v*s, w*s}); } for (auto good: goods){ for (int j = m; j >= good.v; j--){ f[j] = max(f[j], f[j - good.v] + good.w); } } cout 多重背包的单调队列优化（参考楼教主--男人八题) 分组背包问题 每组物品有若干，同组内的物品只能选一个 有 N 组物品和一个容量是 V 的背包。 每组物品有若干个，同一组内的物品最多只能选一个。 每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。 求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。 输出最大价值。 输入格式 第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。 接下来有 N 组数据： 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量； 每组数据接下来有 Si 行，每行有两个整数 vij,wij，用空格隔开，分别表示第 i 个物品组的第 j 个物品的体积和价值； 输出格式 输出一个整数，表示最大价值。 算法思路 f[i,j] 只从前i组物品中选，且总体积不大于j的所有做法 对于第i组，不选，选第1个物品，选第2个物品，…, 选第k个物品 枚举第k个：f[i,j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k]); 用的是上层状态则从大到小枚举，用的是本层状态则从小到大枚举 代码实现 // 当没有思路时，回到最初的步骤去思考应该如何做 // f[i,j] 只从前i组物品中选，且总体积不大于j的所有选法的最大值 // f[i,j] 最多选一个，那么可以不选，选a, 选b, 选c, 等等 // f[i,j] = max(f[i-1,j], f[i-1,j-v[k]]+w[k]) 上层从大到小枚举 #include #include using namespace std; const int N = 110; int n, m; int v[N][N], w[N][N], s[N]; int f[N]; int main() { cin >> n >> m; for (int i = 1; i > s[i]; // for (int j = 0; j > v[i][j] >> w[i][j]; } for (int i = 1; i = 0; j --) // 枚举体积 for (int k = 0; k = v[i][k]) // 务必使其有意义；第i组第k个物品 f[j] = max(f[j], f[j - v[i][k]] + w[i][k]); cout 混合背包问题 二维费用的背包问题 对于每件物品，具有两种不同的费用，存在两种不同的限制。一般形式是对物品总数的限制。 背包问题求方案数 有1分，2分，5分，10分四种硬币，每种硬币数量无限，给定n分钱(n 输入例子1: 13 输出例子1: 16 算法思想：将状态由最大价值改为方案数 求背包问题的方案 算法思想： 记忆化存储最优解的转换过程 逆推得到最优解 题目 LeetCode 368. Largest Divisible Subset (medium) 有依赖的背包问题 N个物品，有重量数组w,和价值数组v,背包承重为M 求背包能装的最大重量（领扣92） 求背包能装的最大价值 (领扣125) 01背包问题，从最大体积向0体积枚举； 完全背包问题，从0体积向最大体积枚举； 题目 LeetCode 300. Longest Increasing Subsequence (medium) LeetCode 322. Coin Change (medium) LeetCode 474. Ones and Zeroes (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/树形dp.html":{"url":"chapter/dp/树形dp.html","title":"树形dp","keywords":"","body":"树形dp LeetCode 124. Binary Tree Maximum Path Sum (hard) LeetCode 1245. Tree Diameter (medium) （邻接表上的树形dp） LeetCode 543. Diameter of Binary Tree (easy) LeetCode 333. Largest BST Subtree (medium) LeetCode 337. House Robber III (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/状态压缩dp.html":{"url":"chapter/dp/状态压缩dp.html","title":"状态压缩dp","keywords":"","body":"状态压缩dp 状态压缩dp，用整数来描述一个集合从而达到节省时间空间，让代码更加的好写 整数的二进制表示状态，通过位运算进行状态转换 旅行商问题 旅行商问题（Traveling Salesman Problem）,简称TSP问题 问题描述： n个点，m条边，找出最短的回路 题目练习: 旅行商问题 算法1 暴力枚举 假设有1，2，3，4，5五个点 枚举所有排列： 1 —> 2 -> 3 -> 4 -> 5 1 —> 2 -> 3 -> 5 -> 4 1 —> 2 -> 4 -> 3 -> 5 1 —> 2 -> 4 -> 5 -> 3 ... 5 —> 4 -> 3 -> 2 -> 1 时间复杂度 算法2 状态压缩DP 枚举所有排列存在重复计算的问题 集合用S表示，dp[S][i]表示走过了S集合，到达位置i的最小代价 比如: 集合U(1,3,4)停留在位置3，S=01101表示集合U(1,3,4),状态表示为dp[01101][3] 状态转换： i->j的转换过程：dp[S|1 时间复杂度 代码实现 #include using namespace std; const int N = (1 > n >> m; while (m--) { int u, v, w; cin >> u >> v >> w; dis[u][v] = w; dis[v][u] = w; } memset(dp, 0, sizeof dp); memset(dis, 0x3f, sizeof dis); int M = (1 j if (!(s >> j & 1)) { // 如果当前城市j还没有经过,我们从i走向j int next = s | (1 P和NP P问题(Polynomial): 时间复杂度都可以用O（n^k）来表示，k是一个常数，多项式时间算法 NP问题(Non-deterministic Polynomial): 意思是“不确定是否能用多项式时间解决”，时间复杂度：O(2^n),甚至O（n!）, 这些时间复杂度随着问题规模n的增长，计算量的增长速度是非常恐怖的 NP = P？ 有些科学家认为，所有的NP问题终究都可以在多项式时间内解决，只是我们暂时还没有找到方法；也有些科学家认为，某些NP问题永远无法在多项式时间内解决。这个业界争论可以用一个公式来表达：NP = P？ 归约和NPC 归约的定义：只要有办法解决Q'，就一定能够解决Q，则称：问题Q归约于问题Q' 归约可以逐级传递，比如问题A归约于问题B，问题B归约于问题C，问题C归约于问题D，那么我们可以说问题A归约于问题D NPC问题（NP-complete）：存在归约关系的NP问题，可以用归约的方式求解 就数量上而言，NP问题远比P问题要多，而NP之中的NPC问题也仅占极少数，所以P、NP、NPC之间的关系可以用下图来表示： 旅行商问题就是一个NPC问题 题目 AcWing91.最短Hamilton路径（最短哈密顿距离） AcWing327.玉米田 LeetCode 464. Can I Win (medium) LeetCode 526. Beautiful Arrangement (medium) LeetCode 935. Knight Dialer (medium) LeetCode 1125. Smallest Sufficient Team (hard) LeetCode 1349. Maximum Students Taking Exam (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/数位dp.html":{"url":"chapter/dp/数位dp.html","title":"数位dp","keywords":"","body":"数位dp 数位 DP 问题往往都是这样的题型，给定一个闭区间 [l, r]，让你求这个区间中满足 某种条件 的数的总数。 数位dp用来处理计数问题 例题：计算1到N中2出现的次数 算法思路： 求2在每一位上出现的次数，求和 分情况讨论 代码实现 class Solution { public: int numberOf2sInRange(int num) { int ans = 0; int n = 0; int tmp = num; while (tmp)n++, tmp/=10; // 获取num的位数 for (int i = 0; i 2) { int f = num / (int)pow(10, n-i) + 1; int b = pow(10, n-i-1); ans += f * b; } else { int f = num / (int)pow(10, n-i); int b = (int)pow(10, n-i -1); ans += f * b; } if (k == 2) ans += num % (int)pow(10, n-i-1) + 1; } return ans; } }; 题目 LeetCode 233. Number of Digit One (hard) LeetCode 902. Numbers At Most N Given Digit Set (hard) LeetCode 1015. Smallest Integer Divisible by K (medium) 程序员面试金典；面试题 17.06. 2出现的次数 acwing 338. 计数问题 hdu2089.不要62 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/计数型dp.html":{"url":"chapter/dp/计数型dp.html","title":"计数型dp","keywords":"","body":"计数型dp 计数型dp都可以以组合数学的方法写出组合数，然后dp求组合数 题目 LeetCode 62. Unique Paths (medium) LeetCode 63. Unique Paths II (medium) LeetCode 96. Unique Binary Search Trees (medium) (卡特兰数) LeetCode 1259. Handshakes That Don't Cross (hard) (卢卡斯定理求大组合数模质数) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/递推型dp.html":{"url":"chapter/dp/递推型dp.html","title":"递推型dp","keywords":"","body":"递推型dp 所有线性递推关系都可以用矩阵快速幂做，可以O(logN)，最典型是斐波那契数列 题目 LeetCode 70. Climbing Stairs (easy) LeetCode 509. Fibonacci Number (easy) LeetCode 935. Knight Dialer (medium) LeetCode 957. Prison Cells After N Days (medium) LeetCode 1137. N-th Tribonacci Number (easy) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/概率型dp.html":{"url":"chapter/dp/概率型dp.html","title":"概率型dp","keywords":"","body":"概率型dp 求概率，求数学期望 题目 LeetCode 808. Soup Servings (medium) LeetCode 837. New 21 Game (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/博弈型dp.html":{"url":"chapter/dp/博弈型dp.html","title":"博弈型dp","keywords":"","body":"博弈型dp 博弈型dp跟其他类型动态规划不同：博弈型往往从第一步开始分析 策梅洛定理，SG定理，minimax 翻转游戏 LeetCode 293. Flip Game (easy) LeetCode 294. Flip Game II (medium) Nim游戏 LeetCode 292. Nim Game (easy) 石子游戏 一个数字序列，两名玩家，两人依次从左右两个端点取，两人都会做出最佳选择 输出第一位玩家是否会取的胜利 LeetCode 486. Predict the Winner (medium) LeetCode 877. Stone Game (medium) 井字游戏 LeetCode 348. Design Tic-Tac-Toe (medium) LeetCode 794. Valid Tic-Tac-Toe State (medium) LeetCode 1275. Find Winner on a Tic Tac Toe Game (easy) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/dp/记忆化搜索.html":{"url":"chapter/dp/记忆化搜索.html","title":"记忆化搜索","keywords":"","body":"记忆化搜索 本质是 dfs + 记忆化，用在状态的转移方向不确定的情况 练习 LeetCode 329. Longest Increasing Path in a Matrix (hard) LeetCode 576. Out of Boundary Paths (medium) AcWing 901. 滑雪 LeetCode 1293. Shortest Path in a Grid with Obstacles Elimination (hard) TODO Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/并查集.html":{"url":"chapter/并查集.html","title":"并查集","keywords":"","body":"概念 并查集(Union-Find Set)，也称为不相交集数据结构（Disjointed Set Data Structure）， 指一系不相交的集合(Sets)，提供合并（Union）和查找(Find)两种操作。 总结：一种用来 解决集合查询合并 的数据结构，支持 近乎O(1)的find操作 和 近乎O(1)的union操作 两个基本操作 find(int i) 判断是否属于同一集合 find(i)即查找I所归属的集合，通常我们使用find(i)和find(j)判断i和j是否连通，即是否属于同一个集合 union(int i , int j) 将两个集合进行合并 顾名思义，union方法即将I和J所在的两个集合连通起来，执行这个方法后，I所在集合和所有元素和J所在集合的所有元素都连通 可以解决的问题（适用场景） 有N个点，用M条线进行两两相连的操作（相连即为合并操作） 问A点和B点是否连通 判断 find(A) == find(B) 问连通块的总个数 for i:0~n cnt+= i != find(i) 问A点所在连通块的节点个数 for i:0~n; find(A) == find(i) && cnt++ 判断是否存在环路 进行合并操作时，先判断是否连通，如果已经连通，则存在环路，此时进行合并会死循环 代码模板 初始化 for (int i = 0; i 查找find int find(int x) { if (p[x] == x) return x; return p[x] = find(p[x]); // 带路径压缩 } 合并Union 老大哥之间合并，跟小弟没关系 void unionA(int a, int b){ p[find(a)] = find(b); // a 合并到 b; 谁的老大哥被改变了，谁就是被合并了； } 完整版代码 int f[N]; for (int i = 0; i 带rank的路径压缩实现（了解） class Solution { public: void makeSet(int n){ vector p(n, 0); for (int i = 0; i rank(n, 0); } int find(vector &p, int x) { if (p[x] != x) { p[x] = find(p, p[x]); //路径压缩 } return p[x]; } void unionSet(vector &p, vector &rank, int x, int y) { x = find(p, x); y = find(p, y); if (rank[x] 题目 图论 LeetCode 547. Friend Circles (medium) LeetCode 803. Bricks Falling When Hit (hard) LeetCode 1319. Number of Operations to Make Network Connected (medium) LeetCode 765. Couples Holding Hands (hard) LeetCode 684. Redundant Connection (medium) LeetCode 924. Minimize Malware Spread (hard) 岛屿问题 LeetCode 200. Number of Islands (medium) LeetCode 695. Max Area of Island (medium) 简单集合合并 LeetCode 128. Longest Consecutive Sequence (hard) 拓展阅读 算法导论-第21章:用于不想交集合的数据结构 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/位运算.html":{"url":"chapter/位运算.html","title":"位运算","keywords":"","body":"位运算 六种基本运算 与 a & b 或 a | b 取反 ~a 异或 a ^ b 左移 右移 >> 技巧型运算 x & -x lowbits运算: lowbit(x) = x & -x 应用: 得到x的二进制表示中最右边的一个1 推导: 负数 = 正数的补码 + 1 模拟加法 a ^ b相当于 a 与 b 的二进制的不进位相加 配合移位操作可以实现加法操作 模拟乘以2的幂 x 相当于 x * 2的k次幂 模拟除以2的幂 x >> k 相当于 x / 2的k次幂 比如：我们在使用二分算法时，获取mid，可以 使用 mid = l + (r - l) >> 1 模拟整除判断 (x & m) == 0 相当于 x % (m + 1) == 0 我们常用 x & 1 == 0 来判断 x是否是偶数就是利用此条性质 举例：(x & 3) == 0 相当于 x % 4 == 0 异或运算交换两个元素 a = a ^ b b = a ^ b a = a ^ b 将第k位置为1(k从0开始) x |= (1 将第k位置为0 x &= ~(1 判断第k位是不是1 (x >> i) & 1 或者 x & (1 删除最后一位的1 x & (x - 1) x ^ (x & -x) 练习题目 只出现一次的数字 LeetCode 136. Single Number (easy) 异或运算求解 LeetCode 137. Single Number II (medium) 三进制思路 + 状态机 LeetCode 260. Single Number III (medium) 低位运算 其他题目 LeetCode 201. Bitwise AND of Numbers Range (medium) LeetCode 231. Power of Two (easy) LeetCode 371. Sum of Two Integers (easy) LeetCode 405. Convert a Number to Hexadecimal (easy) LeetCode 421. Maximum XOR of Two Numbers in an Array (medium) LeetCode 476. Number Complement (easy) LeetCode 477. Total Hamming Distance (medium) LeetCode 762. Prime Number of Set Bits in Binary Representation (easy) LeetCode 1009. Complement of Base 10 Integer (easy) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/图论.html":{"url":"chapter/graph/图论.html","title":"图论","keywords":"","body":"图论 图论主要掌握dfs、bfs、flood fill、拓扑排序、最短路、二分图、最小生成树等算法 图论的题目重点考察建图 记忆算法的思路，而不是代码 图的一些概念 入度，出度 顶点，边，权 环 拓扑排序 最短路 最小生成树 二分图 题目 LeetCode 997. Find the Town Judge (easy) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/树与图的遍历.html":{"url":"chapter/graph/树与图的遍历.html","title":"树与图的遍历","keywords":"","body":"DFS和BFS 对比DFS和BFS BFS 空间是指数级别的，大 不会有爆栈风险 可以求最短，最小 DFS 空间和深度成正比，小！ 有爆栈的风险，比如深度最坏可能有1e5层，会爆栈（C++一般4M）；层信息都放在栈空间里 不能搜最短、最小 注意事项 判断当前节点、层是否已得到最终解 判断是否可以剪枝 防止循环遍历问题（比如存在环路，要退出） 遍历顺序如何选择（比如是弧头到弧尾还是弧尾到弧头） flood fill算法 LeetCode 733. Flood Fill (easy) LeetCode 200. Number of Islands (medium) LeetCode 542. 01 Matrix (medium) LeetCode 695. Max Area of Island (medium) 二分图判定 二分图判定 拓扑排序 拓扑排序 习题 LeetCode 111. Minimum Depth of Binary Tree (easy) LeetCode 279. Perfect Squares (medium) LeetCode 130. Surrounded Regions (medium) LeetCode 543. Diameter of Binary Tree (easy) LeetCode 127. Word Ladder (medium) LeetCode 542. 01 Matrix (medium) LeetCode 695. Max Area of Island (medium) LeetCode 886. Possible Bipartition (medium) LeetCode 1377. Frog Position After T Seconds (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/拓扑排序.html":{"url":"chapter/graph/拓扑排序.html","title":"拓扑排序","keywords":"","body":"拓扑排序 应用场景 拓扑排序的一个重要应用：判断AOV网中是否存在环。对有向图构造拓扑排序，如果所有顶点都在它的拓扑序列中，则该AOV网必定不存在环。 算法过程 在图中找到一个入度为0的点，加入到维护的结果队列 对图进行拆点操作，拆掉这个点和所有相连的边 重复上面的两步，所有点都已拆除（拓扑序列中已经包含所有点） 拓扑排序实际上是BFS的一种特殊情况，每次加入队列的点是入度为0的点，加入队列后拆掉相邻的边；记录已经拆掉的点 练习题目 LeetCode 207. Course Schedule (medium) LeetCode 210. Course Schedule II (medium) LeetCode 802. Find Eventual Safe States (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/最短路.html":{"url":"chapter/graph/最短路.html","title":"最短路","keywords":"","body":"最短路 最短路算法的分类： 单源最短路 所有边权都是正数 朴素的Dijkstra算法 O(n^2) 适合稠密图 堆优化版的Dijkstra算法 O(mlog n)（m是图中节点的个数）适合稀疏图 存在负权边 Bellman-Ford O(nm) spfa 一般O(m),最坏O(nm) 多源汇最短路 Floyd算法 O(n^3) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/朴素的Dijkstra算法.html":{"url":"chapter/graph/朴素的Dijkstra算法.html","title":"朴素的Dijkstra算法","keywords":"","body":"朴素的Dijkstra算法 集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷 for v: 1 ~ n t s 用t更新其他点的距离 朴素的Dijkstra算法往往是稠密图，用邻接矩阵来存储 算法模板 int g[N][N]; // 存储每条边；为稠密阵所以用邻接矩阵存储 int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); //初始化距离 0x3f代表无限大 dist[1] = 0; //第一个点到自身的距离为0 for (int i = 0; i dist[j])) t = j; st[t] = true; // t号点的最短路已经确定 // 用t更新其他点的距离 for (int j = 1; j 时间复杂是 O(n2+m), n 表示点数，m 表示边数 题目 AcWing849. Dijkstra求最短路 I LeetCode 743. Network Delay Time (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/堆优化版的Dijkstra算法.html":{"url":"chapter/graph/堆优化版的Dijkstra算法.html","title":"堆优化版的Dijkstra算法","keywords":"","body":"堆优化版的Dijkstra算法 集合S：当前已经确定最短距离的点 dist[1] = 0, dist[i] = 正无穷 for v: 1 ~ n t s 用t更新其他点的距离 ; O(mlogN) 稀疏图用堆优化版的Dijkstra算法 时间复杂度 O(mlogN) 代码实现 堆优化版的Dijkstra算法有点像宽搜 class Solution { public: int networkDelayTime(vector>& times, int N, int K) { const int INF = 0x3f3f3f3f; typedef pair PII; // first:距离; second: 几号点 vector st(N+1, false); // 是否已得到最短距离 vector dist(N+1, INF); // 距离起始点的最短距离 unordered_map> graph; // 邻接表；u->v,权重w priority_queue, greater> heap; // 小顶堆；维护到起始点的最短距离和点 for (auto &t: times){ // 初始化邻接表 graph[t[0]].push_back({t[2],t[1]}); } heap.push({0, K}); dist[K] = 0; while(heap.size()){ auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; // 之前更新过，是冗余备份 st[ver] = true; for (auto &p: graph[ver]){ if (dist[p.second] > distance + p.first){ // 用t去更新其他点到起始点的最短距离 dist[p.second] = distance + p.first; heap.push({dist[p.second], p.second}); } } } int ans = 0; for (int i = 1; i 题目 LeetCode 1368. Minimum Cost to Make at Least One Valid Path in a Grid (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/Bellman-Ford算法.html":{"url":"chapter/graph/Bellman-Ford算法.html","title":"Bellman-Ford算法","keywords":"","body":"Bellman-Ford算法 算法思路 n个点，m条边 循环n次 遍历所有边u->v,权w (松弛操作) dist[v]=min(dist[v], dist[u]+w) 应用 处理有负权边的图 循环次数的含义：循环K次后，表示不超过K条边的最短距离 有边数限制的最短路，只能用Bellman-Ford算法，不能用spfa算法 如果有负权回路，最短路不一定存在 - Bellman-Ford算法可以求出是否有负环 第n循环后，还有更新，说明路径上有n+1个点，也就是存在环，还有更新，说明环是负环 循环n次后, 所有的边u->v,权w满足三角不等式:dist[v] 代码实现 LeetCode 787. Cheapest Flights Within K Stops (medium) Bellman-Ford算法 class Solution { public: int findCheapestPrice(int n, vector>& flights, int src, int dst, int K) { const int INF = 0x3f3f3f3f; vector dist(n, INF); // 到起点的最短距离 vector backup(n); // 防止串联 dist[src] = 0; for (int i = 0; i INF /2) return -1; return dist[dst]; } }; Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/spfa算法.html":{"url":"chapter/graph/spfa算法.html","title":"spfa算法","keywords":"","body":"spfa算法 在各个方面都好于Bellman-Ford算法 但是不能求有边数限制的最短路 SPFA算法是单源最短算法中限制最小的算法，只要没有负环，就可以用SPFA算法，一般的只要求最短路就不含有负环 SPFA算法是对Bellman-Ford算法的优化 算法思路 n个点，m条边 对Bellman-Ford算法进行优化： 循环n次 遍历所有边u->v,权w (松弛操作) dist[v]=min(dist[v], dist[u]+w) ; 只有dist[u]变小了，dist[v]才会变小 spfa算法步骤 queue while queue 不为空 t queue.pop() 用 t 更新所有出边 t –> v，权值为w queue 时间复杂度: 一般：O(m) 最坏：O(nm) 场景 存在负权边，求单源最短路 spfa也能解决权值为正的图的最短距离问题，且一般情况下比Dijkstra算法还好 spfa算法更为通用，在求单源最短路的时候，我们可以先考虑spfa算法，如果数据被卡，再考虑实现别的单源最短路算法；一般笔面试题数据都不会被卡，OI，ACM可能被卡 代码实现 LeetCode 743. Network Delay Time (medium) spfa算法 class Solution { public: int networkDelayTime(vector>& times, int N, int K) { const int INF = 0x3f3f3f3f; vector dist(N+1, INF); // 保存到起点的距离 vector st(N+1, false); // 是否最短 typedef pair PII; unordered_map> edges; // 邻接表 queue q; q.push(K); dist[K] = 0; st[K] = true; // 已经在队列中 for (auto &t: times){ edges[t[0]].push_back({t[1], t[2]}); } while (!q.empty()){ auto t = q.front(); q.pop(); st[t] = false; for (auto &e: edges[t]){ int v = e.first, w = e.second; if (dist[v] > dist[t] + w){ dist[v] = dist[t] + w; if (!st[v]){ q.push(v); st[v] = true; } } } } int ans = *max_element(dist.begin()+1, dist.end()); return ans == INF ? -1: ans; } }; spfa算法求负环 Acwing 852. spfa判断负环 算法思路 增加cnt[N]来记录最短路的边数 当最短路的边数大于等于n，可知经过的点大于等于n+1 一共n个点，根据抽屉原理可知最短路存在负环 代码实现 #include using namespace std; typedef pair PII; unordered_map> edges; // 邻接表 int n, m; // n个点，m条边 const int N = 2010; int dist[N]; // 到起始点的最小距离 bool st[N]; // 在队列中是否存在 int cnt[N]; // 记录最短路的边数 bool spfa(){ queue q; for (int i = 1; i dist[u] + w){ dist[v] = dist[u] + w; // 更新最短路 权值 cnt[v] = cnt[u] + 1; // 更新经过的边数 // 存在负环；边数>=n,经过的点>=n+1;根据抽屉原理得，最短路存在负环 if (cnt[v] >= n) return true; if (!st[v]){ q.push(v); st[v] = true; } } } } return false; } int main(){ cin >> n >> m; while (m--){ // 构造图 int u, v, w; cin >> u>> v>> w; edges[u].push_back({v, w}); } if (spfa()) puts(\"Yes\"); else puts(\"No\"); return 0; } Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/Floyd算法.html":{"url":"chapter/graph/Floyd算法.html","title":"Floyd算法","keywords":"","body":"Floyd算法 多源汇最短路 for (k = 1; k for (i = 1; i for (j = 1; j d[i,j] = min(d[i,j], d[i,k]+d[k,j]) 算法原理 floyd算法是基于动态规划的 d[k, i, j] 表示 从i出发，只经过1~k到达j点的最短距离 题目 AcWing 854. Floyd求最短路 #include using namespace std; const int INF = 0x3f3f3f3f; const int N = 210; int n, m, k; // n个点，m条边，k次询问 int grid[N][N]; // 图的矩阵存储 int d[N][N]; // 最短距离 void floyd(){ for (int k = 1; k > n >> m >> k; for (int i = 1; i > u >> v >> w; d[u][v] = min(d[u][v], w); // 重边取最小 } floyd(); // floyd计算多源最短路 while (k--){ // k次询问 cin >> u >> v; if (d[u][v] > INF/2) puts(\"impossible\"); // 由于存在负权边，所以比INF/2大，就是不可达 else cout Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/二分图.html":{"url":"chapter/graph/二分图.html","title":"二分图","keywords":"","body":"二分图 一个图是二分图，当且仅当图中不含有奇数环 反之，如果图中不含有奇数环，则一定是二分图 染色法判定二分图 染色法是判断二分图最常用的方法，当且仅当所有节点被染色，且没有冲突发生，证明该图是二分图 代码实现 AcWing 860. 染色法判定二分图 #include using namespace std; int n, m ; const int N = 1e5+10; int st[N]; // 0:未染色，1:红；-1;黑色(或者搞成0，1，2，用3-color换颜色) unordered_map> edges; bool paint(int x, int color){ if (st[x]!=0) return st[x] == color; st[x] = color; for (auto &v: edges[x]){ if (!paint(v, -color)) return false; } return true; } int main(){ cin >> n >> m; int u, v; while (m--){ cin >> u >> v; edges[u].push_back(v); edges[v].push_back(u); } memset(st, 0 ,sizeof st); bool ans = true; for (int i = 1; i 匈牙利算法(求二分图的最大匹配) 模板 //match[j]=a,表示女孩j的现有配对男友是a int match[N]; //st[]数组我称为临时预定数组，st[j]=a表示一轮模拟匹配中，女孩j被男孩a预定了。 int st[N]; //这个函数的作用是用来判断,如果加入x来参与模拟配对,会不会使匹配数增多 bool find(int x) { //遍历自己喜欢的女孩 for(int i = h[x] ; i != -1 ;i = ne[i]) { int j = e[i]; if(!st[j]){//如果在这一轮模拟匹配中,这个女孩尚未被预定 st[j] = true;//那x就预定这个女孩了 //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功,更新match if(!match[j]||find(match[j])) { match[j] = x; return true; } } } //自己中意的全部都被预定了。配对失败。 return false; } //记录最大匹配 int res = 0; for(int i = 1; i 代码实现 #include #include using namespace std; const int N = 510 , M = 100010; int n1,n2,m; int h[N],ne[M],e[M],idx; bool st[N]; int match[N]; void add(int a , int b){ e[idx] = b, ne[idx] = h[a], h[a] = idx++; } int find(int x) { //遍历自己喜欢的女孩 for(int i = h[x] ; i != -1 ;i = ne[i]) { int j = e[i]; if(!st[j]){//如果在这一轮模拟匹配中,这个女孩尚未被预定 st[j] = true;//那x就预定这个女孩了 //如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功 if(!match[j]||find(match[j])){ match[j] = x; return true; } } } //自己中意的全部都被预定了。配对失败。 return false; } int main() { memset(h,-1,sizeof h); cin>>n1>>n2>>m; while(m--) { int a,b; cin>>a>>b; add(a,b); } int res = 0; for(int i = 1; i 题目 LeetCode 785. Is Graph Bipartite? (medium) LeetCode 886. Possible Bipartition (medium) LeetCode 851. Loud and Rich (medium) LeetCode 994. Rotting Oranges (easy) LeetCode 980. Unique Paths III (hard) LeetCode 1254. Number of Closed Islands (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/最小生成树.html":{"url":"chapter/graph/最小生成树.html","title":"最小生成树","keywords":"","body":"最小生成树 最小生成树处理的是无向图 常用的两个算法 Prim算法（普利姆算法） 朴素版Prim O(n^2) 稠密图✅ 堆优化Prim O(mlog n) 不常用❎ Kruskal算法 (克鲁斯卡尔算法) O(mlogm) 稀疏图✅ 稀疏图用Kruskal算法，稠密图用朴素版Prim算法，堆优化版Prim算法一般不会用 二分图的判定 染色法 O(n+m) 判断能否被二染色 匈牙利算法 O(mn),实际运行时间一般远小于O(mn) 求二分图的最大匹配 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/Prim算法.html":{"url":"chapter/graph/Prim算法.html","title":"Prim算法","keywords":"","body":"Prim算法 dist[i] for (i=0; i t 用 t 更新其他点到集合的距离 s[t] = true 朴素版Prim算法 代码实现 Acwing 858. Prim算法求最小生成树 /* S:当前已经在联通块中的所有点的集合 1. dist[i] = inf 2. for n 次 t using namespace std; const int N = 510, INF = 0x3f3f3f3f; int n, m; // n个点，m条边 int g[N][N];// 邻接矩阵 int dist[N]; // 存储其他点到S的距离 bool st[N]; // 是否已得到最短距离 int prim(){ memset(dist, INF, sizeof dist); int res = 0;// 如果图不连通，返回INF，否则返回res for (int i = 0; i dist[j])){ t = j; } } // 找到了距离集合S 最近的点t if (i && dist[t] == INF) return INF; // 不连通 if (i) res += dist[t]; st[t] = true; // 更新到集合S的最短距离 for (int j = 1; j > n >> m; for (int i = 1; i > u >> v>> w; g[u][v] = g[v][u] = min(g[u][v], w); } int t = prim(); if (t == INF) puts(\"impossible\"); else cout 时间复杂度 朴素版Prim O(n^2) 适用于稠密图 堆优化版Prim算法 基本不用，只需要掌握 朴素版Prim算法 和 Kruskal算法 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/graph/Kruskal算法.html":{"url":"chapter/graph/Kruskal算法.html","title":"Kruskal算法","keywords":"","body":"Kruskal算法 将所有边按权重从小到大排序 O(mlogm) 枚举每条边u v,权重w if a,b不连通 将这条边加入集合中 应用场景 稀疏图的 最小生成树 代码实现 AcWing 859. Kruskal算法求最小生成树 /* res 最小生成树中的权重之和 cnt 当前加了多少条边 1.将所有边按权重排序O(mlogm) 2.枚举每条边（并查集应用） if a,b 不连通 加入集合 3.需重载 using namespace std; const int N = 1e5+10, M = 2e5+10, INF = 0x3f3f3f3f; int n, m; // n个点，m条边 int f[N]; // 并查集 struct Edge{ int u, v, w; bool operator > n >> m; int u, v, w; for(int i = 0; i> u >> v >> w; edges[i] = {u, v, w}; } int ans = kruskal(); if (ans > INF/2) puts(\"impossible\"); else cout Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/数学.html":{"url":"chapter/math/数学.html","title":"数学","keywords":"","body":"数学 对于数学问题，分为两个大类： 代数：研究数字 -> 数论 几何：研究图形 -> 图论，更多的图论问题参考《图》那一章，这里只学习基本图形的性质 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/初等数论.html":{"url":"chapter/math/初等数论.html","title":"初等数论","keywords":"","body":"数学知识 完全平方数 质数 约数 最大公约数 逆元 欧拉函数 快速幂 扩展欧几里得算法 中国剩余定理 组合计数 完全平方数 时间复杂度O(1)判断某个数是否是完全平方数 bool isSqr(int n) { int a = (int)(sqrt(n) + 0.5); //四舍五入求整 return a * a == n; } bool isSqr(int n) { int a = (int)(sqrt(n) + 0.0001); return a * a == n; } 以上两种方法均可 质数 试除法判定质数 bool is_prime(int x) { if (x 时间复杂度 O(根号n) AcWing 866. 试除法判定质数 试除法分解质因数 void divide(int x){ for (int i = 2; i 1) printf(\"%d %d\\n\", x, 1); // 输出 剩下的最后一个质因子 } AcWing 867. 分解质因数 筛质数 bool st[N]; // 是否被筛掉； true: 不是质数，被筛掉了 int primes[N], cnt = 0; // primes[]存储所有素数; cnt：当前下标 //朴素筛法-O(nlogn) void get_primes(int x) { for(int i = 2; i AcWing 868. 筛质数 LeetCode 204. Count Primes (easy) 约数 试除法求约数 vector get_divisors(int x) { vector res; for (int i = 1; i 约数个数 和 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck // pi为质因子，ci为质因子的幂 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) // 每个质因子有 ci + 1种取法（取0~ci次） 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) // 直接因式分解证明 最大公约数 欧几里得算法 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 逆元 逆元是模运算中的一个概念 逆元的定义：A 是 B 模 C 的逆元，实际上是指 A * B = 1 mod C，也就是说 A 与 B 的乘积模 C 的余数为 1。可表示为 A = B^(-1) mod C。 打个比方，7 模 11 的逆元，即：7^(-1) mod 11 = 8，这是因为 7 × 8 = 5 × 11 + 1，所以说 7 模 11 的逆元是 8。 逆元的含义：模 C 意义下，A 如果有逆元 B，那么除以 A 相当于乘以 B。 应用 在RSA算法中求私钥中的整数d时，需要使得 (e * d ) % m = 1，该方程等价于 e * d = 1 + y * m （y为整数），也等价于 e * d - y * m = 1。 因此求解d的过程就是求解该二元一次方程组（e和m已知，求解d），即求e模m的逆元。 求逆元的方法 扩展欧几里得算法 a存在模b的乘法逆元的充要条件是gcd(a,b) = 1 费马小定理及欧拉定理 欧拉函数 欧拉函数可以用容斥原理证明 快速幂 求 a 的 k 次方 mod p的结果 (1 原理：平方取模，把k进行二进制拆解，二进制移位运算 时间复杂度 O(logK) int qmi(int a, int k, int p){ LL res = 1; while (k){ if (k & 1) res = (LL)res * a % p; a = (LL)a * a % p; k >>= 1; } return res; } 扩展欧几里得算法 裴（pei）蜀定理 对于任意一对正整数a,b,一定存在x,y, 使得 ax + by = (a, b) (a, b)表示 gcd(a,b)的倍数 => ax + by 能凑出的最小正整数 就是 gcd(a, b) 扩展欧几里得算法 求x, y，使得 ax + by = gcd(a, b) int exgcd(int a, int b, int &x, int &y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 练习: LeetCode 365. Water and Jug Problem (medium) 中国剩余定理 应用: 求解线性同余方程 给定n组数据ai,bi,mi，对于每组数求出一个xi，使其满足ai∗xi≡bi(mod mi)，如果无解则输出-1 也叫《孙子定理》 组合计数 排列组合公式： Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/容斥原理.html":{"url":"chapter/math/容斥原理.html","title":"容斥原理","keywords":"","body":"容斥原理 求[1,n]里能被[2,m]中的数整除的个数 长度为n的由数字0，1，2组成的序列，要求每个数字至少出现1次，这样的序列有多少种 思路 容斥原理用于求解集合的并, 交运算 我们可以借助韦恩图的思想来拆解问题 重点掌握容斥原理的公式 推荐阅读 OI WIKI 概念题 给定一个整数n和m个不同的质数p1,p2,…,pm。 请你求出1~n中能被p1,p2,…,pm中的至少一个数整除的整数有多少个。 AcWing890.能被整除的数 代码实现 #include using namespace std; typedef long long LL; int n, m; int p[20]; // 保存质因子 int main(){ cin >> n >> m; // 求n以内的，能被m个质数整除的所有数个数 for (int i = 0; i> p[i]; int ans = 0; for (int k = 1; k n) {// 乘积大于n，子集越界 t = -1; break; } } } if (t != -1){ // 不越界情况下，容斥原理，统计满足条件个数 if (cnt % 2) ans += n /t; // 集合元素奇数个，相加 else ans -= n/t;// 集合元素偶数个，相减 } } cout 题目 LeetCode 1201. Ugly Number III (medium) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/抽屉原理.html":{"url":"chapter/math/抽屉原理.html","title":"抽屉原理","keywords":"","body":"抽屉原理 n+1个数出现在n个位置，必定有两个数产生冲突 练习题目 剑指offer13. 找出数组中重复的数字 LeetCode 41. First Missing Positive (hard) LeetCode 287. Find the Duplicate Number (medium) LeetCode 442. Find All Duplicates in an Array (medium) LeetCode 448. Find All Numbers Disappeared in an Array (easy) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/约瑟夫环.html":{"url":"chapter/math/约瑟夫环.html","title":"约瑟夫环","keywords":"","body":"约瑟夫环 约瑟夫问题：N个人(编号0，1，2，3，4，...，N-1)围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。 约瑟夫问题，也叫枪毙问题 普通解法 链表或数组模拟整个游戏过程 时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果 公式法 递推公式：f[N][M] = (f[N-1][M] + M) % N 当N=10，M=3时，打表模拟约瑟夫环游戏过程(黄色表示每一轮枪毙掉的位置，绿色表示幸存者在这一轮的位置): f[N][M]表示 N个人报数，每报到M时杀掉那个人，最终胜利者的下标 f(1,3): 只有1个人了，那个人就是胜利者，胜利者下标是0 f(2,3) =（f(1,3) + 3）%2 = 3%2 = 1, 剩2个人，胜利者下标是1 f(3,3) = (f(2,3) + 3))%3 = 3%3 = 1, 剩3个人，胜利者下标是1 f(4,3) = (f(3,3) + 3) % 4 = 0, 剩3个人，胜利者下标是0 ... f(10,3) = 3 以上就是约瑟夫环的逆推过程 代码实现 递归版本 class Solution { public: int lastRemaining(int n, int m) { if (n == 1) return 0; return (lastRemaining(n-1, m) + m) % n; } }; 递推版本 class Solution { public: int lastRemaining(int n, int m) { int live = 0; // 活下去的那个人的位置 for (int k = 2; k Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/卡特兰数.html":{"url":"chapter/math/卡特兰数.html","title":"卡特兰数","keywords":"","body":"卡特兰数 卡特兰数是组合数学中一个常出现在各种计数问题中的数列 其前几项为（从第零项开始）: 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ... 设h(n)为catalan数的第n+1项，令h(0)=1,h(1)=1，catalan数满足递推式： h(n)= h(0)*h(n-1)+h(1)*h(n-2) + ... + h(n-1)*h(0) (n>=2) 另类递推式：h(n)=h(n-1)*(4*n-2)/(n+1) 递推关系的解为： (n=0,1,2,...) 递推关系的另类解为： (n=0,1,2,...) 常用通项公式： 代码模板 第一种推导式：动态规划思想 int h[100]; h[0] = 1; h[1] = 1; for (int i = 2; i 第二种推导式： LL h[100]; h[0] = 1; for (int i = 1; i 通项公式： long long cnt = 1; for (int i = 1; i 应用 括号化 矩阵连乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n)种) [3] 出栈次序 一个栈(无穷大)的进栈序列为1，2，3，…，n，有多少个不同的出栈序列? 凸多边形三角划分 凸多边形划分为三角形，切割线不想交，共有多少种情况？ 街道选择 一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？ 不同的二叉搜索树的数目 给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。（能构成h(N)个） n对括号正确匹配数目 n对括号有多少种正确配对的可能 题目 LeetCode 96. Unique Binary Search Trees (medium) LeetCode 1259. Handshakes That Don't Cross (hard) TODO Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/三门问题.html":{"url":"chapter/math/三门问题.html","title":"概率论--三门问题","keywords":"","body":"三门问题 A,B,C三个门后面只有一个有奖品，游戏规则如下： 你选择一扇门 主持人在知道奖励在哪扇门后面的前提下，排除掉剩下的两扇门中没有奖励的一扇 问你是否应该换另一扇门（换和不换赢得奖品的概率哪一个更大，是多少）? 思路 随机选择一扇门，选中的概率为三分之一，奖品在另两扇门概率是三分之二 主持人帮忙排除掉一扇门后，只剩下两扇门，选哪一扇呢？从第一步中我们知道，奖品在另两扇门概率是三分之二，所以换，获奖概率更大，为三分之二 参考 蒙提霍尔问题（又称三门问题、山羊汽车问题）的正解是什么？ Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/math/计算几何.html":{"url":"chapter/math/计算几何.html","title":"计算几何","keywords":"","body":"计算几何 几何题一般涉及到一些几何性质 推荐学习 OI WIKI计算几何 二维向量相关 LeetCode 149. Max Points on a Line (hard) LeetCode 593. Valid Square (medium) LeetCode 836. Rectangle Overlap (easy) LeetCode 883. Projection Area of 3D Shapes (easy) LeetCode 963. Minimum Area Rectangle II (medium) 面试题 16.14. 最佳直线 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/离散化.html":{"url":"chapter/离散化.html","title":"离散化","keywords":"","body":"离散化 总共的数据范围很大，但是用的数据量很小，也就是用到的数据在整个区间中很稀疏，这时候用到离散化 算法思想 将所有用到过的数映射到从1开始的自然数1,2,3,...,n，从而减小数据范围 算法步骤： 存储所有待离散化的值，排序并去重 查找某个值在离散化后的数组中的下标时，用二分，复杂度O(logK) 板子 vector alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l > 1; if (alls[mid] >= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 板子题 AcWing 802. 区间和 # include using namespace std; typedef pair PII; int n, m; const int N = 300010; int A[N] = {0}; // 存储数组 int S[N] = {0}; // 前缀和数组 vector alls; vector adds; vector querys; int find(int x){ int l = 0, r = alls.size() -1; while (l > 1; if (alls[mid] >= x) r = mid;// 找到第一个大于等于x的元素位置 else l = mid + 1; } return l + 1; } int main(){ cin >> n >> m; while (n--){ int x, val; cin >> x >> val; adds.push_back({x, val}); alls.push_back(x); } while (m--){ int l, r; cin >> l>> r; querys.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 离散化 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); // 处理添加 for (auto add: adds){ A[find(add.first)] += add.second; } // 处理前缀和 for( int i = 1; i Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/树状数组.html":{"url":"chapter/树状数组.html","title":"树状数组","keywords":"","body":"树状数组 也叫Fenwick树、二叉索引树(Binary Indexed Tree) 区间求和可以使用前缀和去解，时间复杂度O(1) 但是如果元素可变呢？ 树状数组适用于 带更新操作 的 区间和查询 结构 代码实现 单点修改，区间查询 基础版本 由A数组建立C数组 int n = A.size(); vector C(n+1, 0); for (int i = 1; i 单点修改 void add(int x, int k){ for (;x 区间查询[1,x],位置0为空 int ask(int x) { int ans = 0; for (; x >0; x-=x&-x) ans +=t[x]; return ans; } 单点修改：add(x, k); 区间查询：ask(r) - ask(l - 1); 完整版代码 class Solution { public: vector t; int n; void build(vector &nums) { // 建树 n = nums.size(); t = vector(n + 1, 0); for (int i = 1; i 0; x -= x & -x) ans += t[x]; return ans; } }; 树状数组时间复杂度 预处理：O(nlog n) 更新和查询：O(log n) 区间修改，单点查询 使用差分，维护差分数组d[i] = a[i] - a[i - 1]。 区间更新变成了[l, r] 两端l和r的更新，点查询也就变成了[1, x]的区间更新。 区间修改，区间查询 使用差分，维护差分数组d1[i] = a[i] - a[i - 1] 和 d2[i] = i (d2[i] - d2[i - 1])。 区间更新的方式和2相同，区间查询是(r + 1) query(d1, r) - query(d2, r)。通过差分推一推就能得到。 当遇到单点更新时，树状数组往往比线段树更实用 树状数组和线段树比较 树状数组功能比线段树少，实现简单，常数小 树状数组通常只能用于区间求和 线段树能够应用于更多场景，包括：处理区间最大值/最小值等一系列问题 线段树实现较复杂，代码长一些 练习题 LeetCode 307. Range Sum Query - Mutable (medium) LeetCode 315. Count of Smaller Numbers After Self (hard) LeetCode 493. Reverse Pairs (hard) 面试题 10.10. 数字流的秩 拓展 poj2352 二维偏序；bzoj1452；bzoj1878；bzoj2743；cf755d Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/线段树.html":{"url":"chapter/线段树.html","title":"线段树","keywords":"","body":"线段树 线段树用于解决 RMQ(Range Minimum/Maximum Query) 问题，即区间最值问题 比如在对数时间内从数组中找到最小值、最大值、总和、最大公约数、最小公倍数等。 相关问题： 一个数组，求任意一个区间的最大的数是多少 一个数组，求任意一个区间的和为多少 修改某个元素后，如何支持上述查询 线段树和ST表时间复杂度 线段树：O(NlogN)预处理，单词询问O(logN) ST表：O(NlogN)预处理，单词询问O(1) 求区间和 const int N = 1e5 + 1; int tree[N] = {0}; int arr[N] = {0}; void build_tree(int node, int start, int end) { // 构建[start, end]区间 if (start == end) { tree[node] = arr[start]; return; } int mid = start + end >> 1; int left_node = 2 * node + 1; int right_node = 2 * node + 2; build_tree(left_node, start, mid); build_tree(right_node, mid + 1, end); tree[node] = tree[left_node] + tree[right_node]; } void update_tree(int node, int start, int end, int idx, int val) { // 更新 idx 的值 if (start == end) { arr[idx] = val; tree[node] = val; return; } int mid = start + end >> 1; int left_node = 2 * node + 1; int right_node = 2 * node + 2; if (idx >= start && idx end) return 0; // 区间外 if (L > 1; int left_node = 2 * node + 1; int right_node = 2 * node + 2; int val_left = query(left_node, start, mid, L, R); int val_right = query(right_node, mid + 1, end, L, R); return val_left + val_right; } int main() { int n = 6; for (int i = 0; i 课程讲解 https://www.bilibili.com/video/av47331849 https://www.acwing.com/blog/content/514/ 习题练习 LeetCode 315. Count of Smaller Numbers After Self (hard) LeetCode 327. Count of Range Sum (hard) 剑指offer 51. 求数组中逆序对的个数 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/ST表.html":{"url":"chapter/ST表.html","title":"ST表","keywords":"","body":"ST表 ST表（Sparse Table) 解决静态RMQ（Range Minimum/Maxium Query，区间最值查询）问题的数据结构 板子 #include using namespace std; #define IO ios::sync_with_stdio(false);cin.tie(0); const int maxn = 1e5 + 5; const int lgn = 19; int n, q; int lg[maxn], f[maxn][19]; void init() { // log函数预处理 lg[1] = 0, lg[2] = 1; for (int i = 3; i > 1] + 1; } } void st() { for (int j = 1; j > n; for (int i = 0; i > f[i][0]; st(); cin >> q; while (q--) { int a, b; cin >> a >> b; cout 扩展LCA倍增 https://www.luogu.com.cn/blog/morslin/solution-p3379 课程学习 https://www.bilibili.com/video/av82319334 练习题 cdoj1591 AcWing1273. 天才的记忆 Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"chapter/system/LRU和LFU.html":{"url":"chapter/system/LRU和LFU.html","title":"LRU和LFU","keywords":"","body":"LRU 和 LFU LRU 和 LFU 是一类系统设计题目 LRU 最近最少使用 LFU 一段时间内最小频率使用 题目 LeetCode 146. LRU Cache (medium) LeetCode 460. LFU Cache (hard) LeetCode 895. Maximum Frequency Stack (hard) Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-04-09 14:49:03 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Copyright © 木易东水 2020 all right reserved，powered by Gitbook修订时间： 2020-03-07 09:08:52 "}}